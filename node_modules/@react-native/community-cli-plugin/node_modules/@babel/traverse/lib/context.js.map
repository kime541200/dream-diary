{"version":3,"names":["_index","require","_t","_context","_hub","VISITOR_KEYS","TraversalContext","constructor","scope","opts","state","parentPath","queue","priorityQueue","shouldVisit","node","enter","exit","type","keys","length","key","create","container","listKey","hub","Hub","undefined","NodePath","get","parent","maybeQueue","path","notPriority","push","visitMultiple","visitQueue","visitSingle","visited","WeakSet","stop","visitIndex","resync","call","contexts","pushContext","has","add","visit","i","popContext","nodes","Array","isArray","exports","default"],"sources":["../src/context.ts"],"sourcesContent":["import NodePath from \"./path/index.ts\";\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type Scope from \"./scope/index.ts\";\nimport type { ExplodedTraverseOptions } from \"./index.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Visitor } from \"./types.ts\";\nimport { popContext, pushContext, resync } from \"./path/context.ts\";\nimport Hub from \"./hub.ts\";\n\nexport default class TraversalContext<S = unknown> {\n  constructor(\n    scope: Scope | null | undefined,\n    opts: ExplodedTraverseOptions<S>,\n    state: S,\n    parentPath: NodePath | undefined,\n  ) {\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  declare parentPath: NodePath | undefined;\n  declare scope: Scope | null | undefined;\n  declare state: S;\n  declare opts: ExplodedTraverseOptions<S>;\n  queue: NodePath[] | null = null;\n  priorityQueue: NodePath[] | null = null;\n\n  /**\n   * This method does a simple check to determine whether or not we really need to attempt\n   * visit a node. This will prevent us from constructing a NodePath.\n   */\n\n  shouldVisit(node: t.Node): boolean {\n    const opts = this.opts as Visitor;\n    if (opts.enter || opts.exit) return true;\n\n    // check if we have a visitor for this node\n    if (opts[node.type]) return true;\n\n    // check if we're going to traverse into this node\n    const keys: string[] | undefined = VISITOR_KEYS[node.type];\n    if (!keys?.length) return false;\n\n    // we need to traverse into this node so ensure that it has children to traverse into!\n    for (const key of keys) {\n      if (\n        // @ts-expect-error key is from visitor keys\n        node[key]\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  create(\n    node: t.Node,\n    container: t.Node | t.Node[],\n    key: string | number,\n    listKey?: string,\n  ): NodePath {\n    const { parentPath } = this;\n    const hub =\n      parentPath == null\n        ? node.type === \"Program\" || node.type === \"File\"\n          ? new Hub()\n          : undefined\n        : parentPath.hub;\n\n    // We don't need to `.setContext()` here, since `.visitQueue()` already\n    // calls `.pushContext`.\n    return NodePath.get({\n      parentPath,\n      parent: node,\n      container,\n      key: key,\n      listKey,\n      hub,\n    });\n  }\n\n  maybeQueue(path: NodePath, notPriority?: boolean) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue!.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container: t.Node[], parent: t.Node, listKey: string) {\n    // nothing to traverse!\n    if (container.length === 0) return false;\n\n    const queue = [];\n\n    // build up initial queue\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node: t.Node, key: string): boolean {\n    if (\n      this.shouldVisit(\n        // @ts-expect-error key may not index node\n        node[key],\n      )\n    ) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue: NodePath[]): boolean {\n    // set queue\n    this.queue = queue;\n    this.priorit